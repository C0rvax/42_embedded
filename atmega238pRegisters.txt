L'ATmega328P possède de nombreux registres, chacun contrôlant des aspects spécifiques du fonctionnement du microcontrôleur. Les manipuler correctement est essentiel pour programmer efficacement. Voici une description détaillée des registres les plus importants, regroupés par fonctionnalité, avec des exemples d'utilisation en C:

I. Registres d'Entrée/Sortie (GPIO):

DDRx (Data Direction Register x) (où x = B, C ou D): Définit la direction (entrée ou sortie) de chaque broche du port.

DDRB: Contrôle la direction des broches du Port B (PB0-PB7).

DDRC: Contrôle la direction des broches du Port C (PC0-PC5).

DDRD: Contrôle la direction des broches du Port D (PD0-PD7).

Configuration:

1: La broche correspondante est configurée en sortie.

0: La broche correspondante est configurée en entrée.

Exemple C:

// Configurer PB5 comme sortie, et PB0 comme entrée
DDRB |= (1 << DDB5);  // PB5 en sortie (DDB5 est un define pour le bit 5 de DDRB)
DDRB &= ~(1 << DDB0); // PB0 en entrée (DDB0 est un define pour le bit 0 de DDRB)
content_copy
download
Use code with caution.
C

PORTx (Port x) (où x = B, C ou D): Écrit une valeur sur les broches configurées en sortie. Active/désactive la résistance de pull-up interne pour les broches configurées en entrée.

PORTB: Contrôle l'état des broches du Port B.

PORTC: Contrôle l'état des broches du Port C.

PORTD: Contrôle l'état des broches du Port D.

Configuration (broches en sortie):

1: La broche correspondante est mise à l'état haut (HIGH).

0: La broche correspondante est mise à l'état bas (LOW).

Configuration (broches en entrée):

1: Active la résistance de pull-up interne.

0: Désactive la résistance de pull-up interne.

Exemple C:

// Mettre PB5 à l'état haut
PORTB |= (1 << PORTB5);  // PORTB5 est un define pour le bit 5 de PORTB
// Mettre PB5 à l'état bas
PORTB &= ~(1 << PORTB5);
// Activer la résistance de pull-up sur PB0 (qui doit être configurée en entrée via DDRB)
PORTB |= (1 << PORTB0);
content_copy
download
Use code with caution.
C

PINx (Pin Input Register x) (où x = B, C ou D): Lit l'état logique des broches du port. Ce registre est en lecture seule.

PINB: Lit l'état des broches du Port B.

PINC: Lit l'état des broches du Port C.

PIND: Lit l'état des broches du Port D.

Configuration: Il n'y a pas de configuration. On lit simplement la valeur.

Exemple C:

// Lire l'état de PB0
if (PINB & (1 << PINB0)) {  // PINB0 est un define pour le bit 0 de PINB
    // PB0 est à l'état haut
} else {
    // PB0 est à l'état bas
}
content_copy
download
Use code with caution.
C

II. Registres du Timer/Counter (Timer0, Timer1, Timer2):

TCCRxA & TCCRxB (Timer/Counter Control Register x A & B) (où x = 0, 1, ou 2): Ces registres configurent le mode de fonctionnement du timer, la source d'horloge (prescaler), et les modes de sortie PWM. Chaque timer a ses propres options de configuration.

Mode de fonctionnement: Normal, CTC (Clear Timer on Compare Match), PWM (Phase Correct, Fast PWM).

Source d'horloge (Prescaler): Détermine la fréquence d'incrémentation du timer. Divise la fréquence d'horloge du système par 1, 8, 64, 256, 1024.

Mode de sortie PWM: Non-inverting, inverting.

Exemple C (Timer0 en mode Fast PWM, prescaler de 8):

// Configurer Timer0 pour Fast PWM, non-inverting mode on OC0A (PD6)
TCCR0A |= (1 << COM0A1) | (1 << WGM01) | (1 << WGM00); // Non-inverting PWM on OC0A, Fast PWM mode
TCCR0B |= (1 << WGM02) | (1 << CS01);                   // Fast PWM mode, Prescaler = 8
// Définir la valeur de comparaison pour OC0A (PD6)
OCR0A = 128;  // 50% duty cycle (environ) si le timer compte jusqu'à 255
DDRD |= (1 << DDD6); // Configurer PD6 (OC0A) en sortie
content_copy
download
Use code with caution.
C

TCNTx (Timer/Counter Register x) (où x = 0, 1, ou 2): Contient la valeur actuelle du compteur. Il s'incrémente à chaque cycle d'horloge (après application du prescaler).

TCNT0, TCNT1, TCNT2: Contiennent la valeur du compteur des timers 0, 1 et 2 respectivement.
Il est possible d'écrire dans ce registre pour initialiser la valeur du compteur.

Exemple C:

// Initialiser la valeur du Timer0
TCNT0 = 0;
content_copy
download
Use code with caution.
C

OCRxA & OCRxB (Output Compare Register x A & B) (où x = 0, 1, ou 2): Utilisés dans les modes CTC et PWM. Quand TCNTx est égal à OCRxA ou OCRxB, une action est effectuée (par exemple, changer l'état d'une broche, générer une interruption).

Exemple C (Timer1 en mode CTC, générer une interruption à chaque fois que TCNT1 == OCR1A):

// Configurer Timer1 en mode CTC, Prescaler = 64
TCCR1A = 0; // Normal operation
TCCR1B |= (1 << WGM12) | (1 << CS10) | (1 << CS11); // CTC mode, Prescaler = 64
OCR1A = 15625; // Valeur pour générer une interruption chaque seconde (avec une horloge de 16MHz et un prescaler de 64)
TIMSK1 |= (1 << OCIE1A); // Activer l'interruption Output Compare A Match
sei(); // Activer les interruptions globales
content_copy
download
Use code with caution.
C
ISR(TIMER1_COMPA_vect) {
    // Code à exécuter à chaque interruption (chaque seconde dans cet exemple)
    PORTB ^= (1 << PORTB5);  // Faire clignoter une LED
}
content_copy
download
Use code with caution.
C

TIMSKx (Timer Interrupt Mask Register x) (où x = 0, 1, ou 2): Active ou désactive les interruptions associées au timer.

OCIE0A, OCIE0B, TOIE0 (pour Timer0): Output Compare A Interrupt Enable, Output Compare B Interrupt Enable, Timer Overflow Interrupt Enable.

OCIE1A, OCIE1B, TOIE1, ICIE1 (pour Timer1): Output Compare A Interrupt Enable, Output Compare B Interrupt Enable, Timer Overflow Interrupt Enable, Input Capture Interrupt Enable.

OCIE2A, OCIE2B, TOIE2 (pour Timer2): Output Compare A Interrupt Enable, Output Compare B Interrupt Enable, Timer Overflow Interrupt Enable.

Exemple C (Activer l'interruption de débordement du Timer0):

TIMSK0 |= (1 << TOIE0); // Activer l'interruption de débordement du Timer0
sei(); // Activer les interruptions globales

ISR(TIMER0_OVF_vect) {
    // Code à exécuter lors du débordement du Timer0
}
content_copy
download
Use code with caution.
C

TIFRx (Timer Interrupt Flag Register x) (où x = 0, 1, ou 2): Contient les flags indiquant qu'une interruption du timer s'est produite. Ces flags sont automatiquement effacés par le matériel lorsqu'on entre dans la routine d'interruption correspondante. On peut aussi les effacer manuellement en écrivant un '1' dans le bit correspondant.

III. Registres de l'ADC (Convertisseur Analogique-Numérique):

ADMUX (ADC Multiplexer Selection Register): Sélectionne le canal analogique à convertir, la tension de référence, et l'ajustement du résultat (left adjust).

REFS[1:0]: Sélectionne la tension de référence (AREF pin, AVCC, Internal 1.1V Voltage Reference).

ADLAR (ADC Left Adjust Result): Ajuste le résultat à gauche. Si ADLAR est à 1, les 8 bits de poids fort du résultat sont stockés dans ADCH, et les 2 bits de poids faible dans ADCL. Si ADLAR est à 0, le résultat est justifié à droite et stocké normalement dans ADCH et ADCL.

MUX[4:0]: Sélectionne le canal analogique à convertir (ADC0 à ADC7 sur les broches d'entrée analogique, ou entrées différentielles).

Exemple C (Sélectionner ADC0, tension de référence AVCC):

ADMUX |= (1 << REFS0); // Tension de référence = AVCC
ADMUX &= ~(1 << REFS1);
ADMUX &= ~((1 << MUX4) | (1 << MUX3) | (1 << MUX2) | (1 << MUX1) | (1 << MUX0)); // Sélectionner ADC0
content_copy
download
Use code with caution.
C

ADCSRA (ADC Control and Status Register A): Contrôle l'activation de l'ADC, le démarrage d'une conversion, le prescaler de l'horloge de l'ADC, et l'activation des interruptions.

ADEN (ADC Enable): Active l'ADC.

ADSC (ADC Start Conversion): Démarre une conversion.

ADATE (ADC Auto Trigger Enable): Active le mode de déclenchement automatique. Utilisé avec ADTS pour choisir la source de déclenchement.

ADIF (ADC Interrupt Flag): Flag indiquant qu'une conversion est terminée. Est mis à 1 quand la conversion est terminée, et est effacé par le matériel lorsqu'on entre dans la routine d'interruption ADC, ou manuellement en écrivant un '1' dans le bit.

ADIE (ADC Interrupt Enable): Active l'interruption ADC.

ADPS[2:0]: Sélectionne le prescaler pour l'horloge de l'ADC. Il est important de choisir un prescaler qui donne une fréquence d'horloge de l'ADC entre 50kHz et 200kHz pour une précision optimale.

Exemple C (Activer l'ADC, prescaler de 128, démarrer une conversion):

ADCSRA |= (1 << ADEN) | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0); // Activer l'ADC, Prescaler = 128
ADCSRA |= (1 << ADSC); // Démarrer une conversion
content_copy
download
Use code with caution.
C

ADCL & ADCH (ADC Data Register Low & High): Contiennent le résultat de la conversion ADC. Le résultat est un entier de 10 bits. Selon la configuration de ADLAR dans ADMUX, les bits sont stockés différemment. Il faut lire ADCL avant ADCH. La lecture de ADCL verrouille les registres ADC et permet de lire ADCH avec la valeur correcte.

Exemple C (Lire le résultat de la conversion):

// Attendre la fin de la conversion
while (ADCSRA & (1 << ADSC));

// Lire le résultat (lire ADCL en premier !)
uint16_t resultat = ADCL;
resultat |= (ADCH << 8); // Combiner ADCH et ADCL pour obtenir la valeur de 10 bits
content_copy
download
Use code with caution.
C

ADCSRB (ADC Control and Status Register B): Contrôle le mode de déclenchement automatique de l'ADC.

IV. Registres de l'UART (Universal Asynchronous Receiver/Transmitter) (série):

UCSRA (USART Control and Status Register A): Contient des flags d'état (e.g., indication de réception de données), et contrôle certaines fonctionnalités de l'UART.

RXC (Receive Complete): Mis à 1 lorsque des données ont été reçues et sont disponibles dans UDR.

TXC (Transmit Complete): Mis à 1 lorsque la transmission est terminée.

UDRE (USART Data Register Empty): Mis à 1 lorsque le registre UDR est vide et prêt à recevoir de nouvelles données à transmettre.

FE (Frame Error), DOR (Data OverRun), UPE (USART Parity Error): Indiquent des erreurs de transmission/réception.

UCSRB (USART Control and Status Register B): Active/désactive le transmetteur et le récepteur, active les interruptions, et configure la taille des données (nombre de bits).

RXEN (Receiver Enable): Active le récepteur.

TXEN (Transmitter Enable): Active le transmetteur.

RXCIE (RX Complete Interrupt Enable): Active l'interruption de réception.

TXCIE (TX Complete Interrupt Enable): Active l'interruption de transmission.

UDRIE (USART Data Register Empty Interrupt Enable): Active l'interruption quand UDR est vide.

UCSZ2 (Character Size): Utilisé en conjonction avec UCSZ1:0 dans UCSRC pour définir la taille des données (5, 6, 7, 8 ou 9 bits).

UCSRC (USART Control and Status Register C): Configure le mode de fonctionnement de l'UART (asynchrone/synchrone), la parité, les bits de stop, et la taille des données. Note: Dans certains anciens microcontrôleurs AVR, UCSRC et UBRRH partagent la même adresse mémoire. Le bit URSEL dans UCSRC doit être mis à 1 lors de l'écriture dans UCSRC, et à 0 lors de l'écriture dans UBRRH. Sur l'ATmega328P, ils ont des adresses distinctes et ce n'est plus nécessaire.

UMSEL[1:0] (USART Mode Select): Sélectionne le mode de fonctionnement (asynchrone, synchrone).

UPM[1:0] (USART Parity Mode): Sélectionne le mode de parité (désactivée, paire, impaire).

USBS (USART Stop Bit Select): Sélectionne le nombre de bits de stop (1 ou 2).

UCSZ[1:0] (Character Size): Utilisé en conjonction avec UCSZ2 dans UCSRB pour définir la taille des données (5, 6, 7, 8 ou 9 bits).

UCPOL (USART Clock Polarity): Définit la polarité de l'horloge dans le mode synchrone.

UBRRH & UBRRL (USART Baud Rate Register High & Low): Définissent le baud rate (vitesse de transmission). Il faut calculer la valeur correcte en fonction de la fréquence d'horloge du microcontrôleur.

UDR (USART Data Register): Le registre de données. C'est le buffer utilisé pour envoyer et recevoir des données. Écrire dans UDR envoie des données, lire UDR reçoit des données.

Exemple C (Initialisation de l'UART, envoi d'un caractère):

// Initialisation de l'UART
void uart_init(uint32_t baudrate) {
  uint16_t ubrr = F_CPU / 16 / baudrate - 1; // Calculer la valeur UBRR
  UBRRH = (ubrr >> 8) & 0x0F; // UBRRH est en fait sur seulement 4 bits
  UBRRL = ubrr;
  UCSRB |= (1 << RXEN) | (1 << TXEN); // Activer le récepteur et le transmetteur
  UCSRC |= (1 << UCSZ1) | (1 << UCSZ0); // 8 bits de données, 1 bit de stop, pas de parité
}

// Envoyer un caractère
void uart_transmit(char data) {
  while (!(UCSRA & (1 << UDRE))); // Attendre que le buffer soit vide
  UDR = data; // Envoyer la donnée
}
content_copy
download
Use code with caution.
C

V. Registres d'Interruption:

SREG (Status Register): Contient des flags d'état, y compris le bit d'interruption globale (I).

I (Global Interrupt Enable): Si mis à 1, les interruptions sont activées. On utilise les fonctions sei() (set interrupt enable) et cli() (clear interrupt enable) pour manipuler ce bit.

Exemple C:

sei(); // Activer les interruptions globales
cli(); // Désactiver les interruptions globales
content_copy
download
Use code with caution.
C

EIMSK (External Interrupt Mask Register): Active/désactive les interruptions externes (INT0, INT1).

EICRA (External Interrupt Control Register A): Configure le mode de déclenchement des interruptions externes (front montant, front descendant, changement d'état, niveau bas).

VI. Registres du SPI (Serial Peripheral Interface):

SPCR (SPI Control Register): Configure le mode de fonctionnement du SPI (master/slave), la polarité et la phase de l'horloge, la vitesse, et active le SPI.

SPSR (SPI Status Register): Contient des flags d'état, comme l'indication de fin de transmission.

SPDR (SPI Data Register): Le registre de données. C'est le buffer utilisé pour envoyer et recevoir des données. Écrire dans SPDR envoie des données, lire SPDR reçoit des données.

VII. Registres du TWI/I2C (Two-Wire Interface/Inter-Integrated Circuit):

TWCR (TWI Control Register): Contrôle les opérations du TWI, comme le démarrage et l'arrêt des transmissions, l'envoi et la réception de données, et la gestion des ACK/NACK.

TWSR (TWI Status Register): Contient des informations d'état sur l'état courant du bus TWI.

TWDR (TWI Data Register): Le registre de données. C'est le buffer utilisé pour envoyer et recevoir des données.

TWAR (TWI Address Register): Contient l'adresse du périphérique TWI.

TWBR (TWI Bit Rate Register): Définit la vitesse de transmission du TWI.

VIII. Autres Registres Importants:

MCUCR (MCU Control Register): Contrôle diverses fonctionnalités du microcontrôleur, comme le mode de mise en veille (sleep mode).

MCUSR (MCU Status Register): Contient des informations sur la cause du dernier reset.

WDTCSR (Watchdog Timer Control and Status Register): Configure le watchdog timer (un timer qui reset le microcontrôleur s'il ne reçoit pas un signal de "vie" régulier, utile pour la robustesse).

Important Considerations:

Include Files: Vous devez inclure le fichier d'en-tête spécifique à l'ATmega328P (<avr/io.h>) pour définir les macros pour les noms de registres et les bits (e.g., DDRB, DDB5, PORTB).

Volatile Keyword: Lorsque vous utilisez des variables globales qui sont modifiées dans des routines d'interruption, déclarez-les avec le mot-clé volatile. Ceci indique au compilateur de ne pas optimiser l'accès à ces variables, car elles peuvent changer de manière asynchrone.

Atomic Operations: Lorsque vous modifiez des variables de plus d'un octet dans une routine d'interruption, vous devez désactiver les interruptions pendant la modification pour éviter des conditions de concurrence (race conditions). Utilisez cli() et sei() pour cela. Une alternative est d'utiliser les fonctions _delay_ms() et _delay_us() fournies par la librairie <util/delay.h> (mais attention, elles bloquent l'exécution du programme pendant la durée spécifiée).

Datasheet: La datasheet de l'ATmega328P est votre référence ultime. Elle contient des informations détaillées sur chaque registre, les bits qu'ils contiennent, et leurs fonctions.

Exemple de code complet pour faire clignoter une LED (PB5):

#include <avr/io.h>
#include <util/delay.h>

#define F_CPU 16000000UL // Fréquence d'horloge du microcontrôleur (16MHz)

int main(void) {
  // Configurer PB5 (Digital pin 13 sur Arduino) en sortie
  DDRB |= (1 << DDB5);

  while (1) {
    // Mettre PB5 à l'état haut
    PORTB |= (1 << PORTB5);
    _delay_ms(500); // Attendre 500 millisecondes

    // Mettre PB5 à l'état bas
    PORTB &= ~(1 << PORTB5);
    _delay_ms(500); // Attendre 500 millisecondes
  }

  return 0;
}
content_copy
download
Use code with caution.
C

Ce guide fournit une bonne base pour comprendre et utiliser les registres de l'ATmega328P. La clé est de lire attentivement la datasheet et d'expérimenter avec des exemples de code pour comprendre comment chaque registre affecte le comportement du microcontrôleur. Bon codage!
